import executable from 'executable';
import { readFile } from 'mz/fs';
import { basename, dirname, extname, join } from 'path';

const COFFEE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md'];

function extensionFor(path) {
  if (path.endsWith('.coffee.md')) {
    return '.coffee.md';
  }
  return extname(path);
}

function basePathFor(path) {
  let extension = extensionFor(path);
  return join(dirname(path), basename(path, extension));
}

export async function shouldConvertFile(path) {
  if (COFFEE_EXTENSIONS.some(ext =>
      path.endsWith(ext) && !path.endsWith(`.original${ext}`))) {
    return true;
  }
  if (isExtensionless(path) && await executable(path)) {
    let contents = await readFile(path);
    let firstLine = contents.toString().split('\n')[0];
    if (firstLine.startsWith('#!') && firstLine.includes('coffee')) {
      return true;
    }
  }
  return false;
}

export function isExtensionless(path) {
  return extensionFor(path) === '';
}

export function backupPathFor(path) {
  let extension = extensionFor(path);
  let basePath = basePathFor(path);
  return basePath + '.original' + extension;
}

/**
 * The resulting path where we should send the given input file. Note that when
 * the input file is an extensionless script, we prefer to keep it extensionless
 * (and decaffeinate handles the shebang line).
 */
export function jsPathFor(path, config) {
  if (config.customNames[path]) {
    return config.customNames[path];
  }
  if (isExtensionless(path)) {
    return path;
  } else {
    return basePathFor(path) + '.js';
  }
}

/**
 * The file generated by decaffeinate for the input file with this name.
 */
export function decaffeinateOutPathFor(path) {
  return basePathFor(path) + '.js';
}

export function isLiterate(path) {
  return path.endsWith('.litcoffee') || path.endsWith('.coffee.md');
}
